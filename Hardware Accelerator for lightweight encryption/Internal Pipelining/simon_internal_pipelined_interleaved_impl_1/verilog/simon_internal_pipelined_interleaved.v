// ********************************************************************
//
// Copyright (C) 1994-2016 Synopsys, Inc. All rights reserved. This Synopsys software and all associated documentation are proprietary to Synopsys, Inc. and may only be used pursuant to the terms and conditions of a written license agreement with Synopsys, Inc. All other use, reproduction, modification, or distribution of the Synopsys software or the associated documentation is strictly prohibited.

// This code was generated by Synopsys's Synphony Model Compiler product and
// is intended for use solely by licensed users of this product.

// VERILOG created by Synphony Model Compiler L-2016.03, Build 2009R, Feb 25 2016
// Date written:             Wed Apr 18 12:47:08 2018

// ********************************************************************

// Generated from /afs/asu.edu/users/v/c/h/vchand32/Downloads/simon_internal_pipelined_interleaved.slx Version 1.20 Last modified date Wed Apr 18 12:45:31 2018
module Simon_encryption_0Sequence_ROM (clk,rst,en,inp,outp);
input clk;
input  rst, en;
input [6:0] inp;
output [15:0] outp;
wire [15:0] Simon_encryption_0Sequence_ROM_CT [0:127];
wire rstSig;
assign rstSig = rst;
wire [15:0] outBuf;
reg  [15:0] romReg/*synthesis translate_off*/= 0/*synthesis translate_on*/;
  assign outBuf = romReg;
assign  outp=outBuf;
  generate
  begin: gen_Simon_encryption_0Sequence_ROM
    assign Simon_encryption_0Sequence_ROM_CT[0]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[1]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[2]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[3]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[4]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[5]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[6]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[7]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[8]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[9]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[10]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[11]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[12]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[13]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[14]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[15]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[16]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[17]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[18]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[19]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[20]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[21]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[22]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[23]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[24]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[25]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[26]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[27]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[28]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[29]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[30]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[31]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[32]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[33]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[34]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[35]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[36]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[37]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[38]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[39]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[40]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[41]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[42]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[43]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[44]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[45]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[46]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[47]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[48]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[49]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[50]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[51]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[52]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[53]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[54]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[55]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[56]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[57]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[58]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[59]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[60]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[61]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[62]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[63]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[64]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[65]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[66]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[67]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[68]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[69]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[70]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[71]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[72]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[73]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[74]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[75]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[76]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[77]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[78]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[79]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[80]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[81]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[82]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[83]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[84]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[85]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[86]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[87]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[88]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[89]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[90]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[91]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[92]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[93]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[94]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[95]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[96]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[97]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[98]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[99]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[100]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[101]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[102]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[103]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[104]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[105]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[106]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[107]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[108]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[109]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[110]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[111]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[112]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[113]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[114]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[115]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[116]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[117]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[118]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[119]=16'b0000000000000001;
    assign Simon_encryption_0Sequence_ROM_CT[120]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[121]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[122]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[123]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[124]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[125]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[126]=16'b0000000000000000;
    assign Simon_encryption_0Sequence_ROM_CT[127]=16'b0000000000000000;
  end //gen_Simon_encryption_0Sequence_ROM
  endgenerate
  always @(posedge clk)
  begin: Simon_encryption_0Sequence_ROM_proc
    integer i;
    if(  rstSig==1) 
     begin
       romReg <= 16'b0;
     end
      else if(en) begin
        romReg <= Simon_encryption_0Sequence_ROM_CT[inp];
  end // if en
  end // Simon_encryption_0Sequence_ROM_proc
endmodule

//----------------------------------------------------

module Simon_encryption_0Sequence (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output [15:0] seq // ufix16_En0
);
wire [15:0] N_2 ;
wire [6:0] N_1 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen58_1_64 ;
wire [0:0] N_GlobalEnable1_0_126 ;
wire [15:0] N_seq_1_127 ;
wire GlobalResetSel;
assign seq = N_2;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen58_1_64 = GlobalEnable1;
  generate
  begin: ROM_block
    wire [6:0] inbuf;
    wire syn_en;
    assign syn_en = N_GlobalEnable1_SubSystem_Convert_AutoGen58_1_64[0];
    assign inbuf=N_1[6:0];
    Simon_encryption_0Sequence_ROM myROM (
     .clk(clk),
      .rst(GlobalResetSel),
      .en(syn_en),
     .inp(inbuf),
     .outp(N_2)
     );
  end // ROM_Block
  endgenerate
generate
begin:  Counter_block
wire [6:0] ldIn;
wire rst, en, enloc;
    assign enloc = 1;
    assign en = (enloc && N_GlobalEnable1_SubSystem_Convert_AutoGen58_1_64[0]);
    assign rst = 0;
assign ldIn = 7'b0;
    synCounter #(
        .en_exists('b1),
        .rst_exists('b0),
        .ld_exists('b0),
        .rdy_exists('b0),
        .ctype(2),
        .ival(0),
        .tval(127),
        .bitwidth(7),
        .isSigned('b0)
      ) myCounter (
        .clk(clk),
        .en(en),
        .grst(GlobalResetSel),
        .rst(rst),
        .up(1'b1),
        .ld(1'b0),
        .din(ldIn),
        .rdy(),
        .cnt(N_1)
      );
    end
  endgenerate
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

module Simon_encryption_0Rounds_block (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output [15:0] X_output2, // ufix16_En0
  output [15:0] X_output1, // ufix16_En0
  input [15:0] key_input, // ufix16_En0
  input [15:0] x_input, // ufix16_En0
  input [15:0] _x_input1 // ufix16_En0
);
wire [15:0] N_5 ;
wire [15:0] N_19 ;
wire [15:0] N_20 ;
wire [15:0] N_21 ;
wire [15:0] N_18 ;
wire [15:0] N_24 ;
wire [15:0] N_1 ;
wire [15:0] N_6 ;
wire [15:0] N_7 ;
wire [3:0] N_2 ;
wire [3:0] N_8 ;
wire [3:0] N_3 ;
wire [3:0] N_11 ;
wire [3:0] N_14 ;
wire [3:0] N_16 ;
wire [15:0] N_4 ;
wire [15:0] N_30 ;
wire [15:0] N_15 ;
wire [15:0] N_17 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen57_1_63 ;
wire [15:0] N_12 ;
wire [15:0] N_13 ;
wire [15:0] N_27 ;
wire [15:0] N_26 ;
wire [15:0] N_9 ;
wire [15:0] N_10 ;
wire [15:0] N_23 ;
wire [15:0] N_25 ;
wire [15:0] N_31 ;
wire [15:0] N_28 ;
wire [15:0] N_29 ;
wire [15:0] N_22 ;
wire [0:0] N_GlobalEnable1_0_128 ;
wire [15:0] N_0x_input1_0_129 ;
wire [15:0] N_x_input_0_130 ;
wire [15:0] N_key_input_0_131 ;
wire [15:0] N_X_output1_1_132 ;
wire [15:0] N_X_output2_1_133 ;
wire GlobalResetSel;
assign X_output2 = N_4;
assign X_output1 = N_30;
  assign N_7 = key_input;
  assign N_5 = x_input;
  assign N_6 = _x_input1;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen57_1_63 = GlobalEnable1;
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay1_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_5), .outp(N_19) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay2_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_19), .outp(N_23) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay3_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_20), .outp(N_29) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay4_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_21), .outp(N_22) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(3) ) Delay5_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_18), .outp(N_26) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay6_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_24), .outp(N_25) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay7_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_1), .outp(N_27) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(3) ) Delay8_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_6), .outp(N_30) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(3) ) Delay9_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_7), .outp(N_28) );
  generate
  begin: Shifter_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_9 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter (
      .inp(tmpIn),
      .shf(N_2[3:0]),
      .outp(medo)
   );
  end // Shifter_block;
  endgenerate
  generate
  begin: Shifter1_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_10 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter1 (
      .inp(tmpIn),
      .shf(N_8[3:0]),
      .outp(medo)
   );
  end // Shifter1_block;
  endgenerate
  generate
  begin: Shifter2_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_12 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter2 (
      .inp(tmpIn),
      .shf(N_3[3:0]),
      .outp(medo)
   );
  end // Shifter2_block;
  endgenerate
  generate
  begin: Shifter3_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_13 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter3 (
      .inp(tmpIn),
      .shf(N_11[3:0]),
      .outp(medo)
   );
  end // Shifter3_block;
  endgenerate
  generate
  begin: Shifter4_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_15 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter4 (
      .inp(tmpIn),
      .shf(N_14[3:0]),
      .outp(medo)
   );
  end // Shifter4_block;
  endgenerate
  generate
  begin: Shifter5_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_17 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter5 (
      .inp(tmpIn),
      .shf(N_16[3:0]),
      .outp(medo)
   );
  end // Shifter5_block;
  endgenerate
  generate
  begin: Binary_Logic6_block
    assign N_18 = (N_15 | N_17);
  end // Binary_Logic6_block;
  endgenerate
  generate
  begin: Binary_Logic5_block
    assign N_21 = (N_12 | N_13);
  end // Binary_Logic5_block;
  endgenerate
  generate
  begin: Binary_Logic4_block
    assign N_31 = (N_27 ^ N_26);
  end // Binary_Logic4_block;
  endgenerate
  generate
  begin: Binary_Logic3_block
    assign N_20 = (N_9 | N_10);
  end // Binary_Logic3_block;
  endgenerate
  generate
  begin: Binary_Logic2_block
    assign N_1 = (N_23 ^ N_25);
  end // Binary_Logic2_block;
  endgenerate
  generate
  begin: Binary_Logic1_block
    assign N_4 = (N_31 ^ N_28);
  end // Binary_Logic1_block;
  endgenerate
  generate
  begin: Binary_Logic_block
    assign N_24 = (N_29 & N_22);
  end // Binary_Logic_block;
  endgenerate
assign N_16 = 4'b1110;
assign N_11 = 4'b1000;
assign N_8 = 4'b1111;
assign N_14 = 4'b0010;
assign N_3 = 4'b1000;
assign N_2 = 4'b0001;
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

module Simon_encryption_0Key_expansion_block (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output [15:0] Key_output3, // ufix16_En0
  output [15:0] Key_output2, // ufix16_En0
  output [15:0] Key_output1, // ufix16_En0
  output [15:0] Key_output, // ufix16_En0
  input [15:0] z, // ufix16_En0
  input [15:0] key_input3, // ufix16_En0
  input [15:0] key_input2, // ufix16_En0
  input [15:0] key_input1, // ufix16_En0
  input [15:0] key_input // ufix16_En0
);
wire [15:0] N_6 ;
wire [15:0] N_9 ;
wire [15:0] N_10 ;
wire [15:0] N_20 ;
wire [15:0] N_5 ;
wire [15:0] N_1 ;
wire [15:0] N_11 ;
wire [15:0] N_25 ;
wire [15:0] N_12 ;
wire [15:0] N_19 ;
wire [3:0] N_13 ;
wire [3:0] N_2 ;
wire [15:0] N_23 ;
wire [3:0] N_3 ;
wire [3:0] N_16 ;
wire [15:0] N_4 ;
wire [15:0] N_31 ;
wire [15:0] N_30 ;
wire [15:0] N_29 ;
wire [15:0] N_17 ;
wire [15:0] N_18 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen56_1_62 ;
wire [15:0] N_14 ;
wire [15:0] N_15 ;
wire [15:0] N_7 ;
wire [15:0] N_8 ;
wire [15:0] N_24 ;
wire [15:0] N_26 ;
wire [15:0] N_22 ;
wire [15:0] N_27 ;
wire [15:0] N_28 ;
wire [15:0] N_21 ;
wire [0:0] N_GlobalEnable1_0_134 ;
wire [15:0] N_key_input_0_135 ;
wire [15:0] N_key_input1_0_136 ;
wire [15:0] N_key_input2_0_137 ;
wire [15:0] N_key_input3_0_138 ;
wire [15:0] N_z_0_139 ;
wire [15:0] N_Key_output_1_140 ;
wire [15:0] N_Key_output1_1_141 ;
wire [15:0] N_Key_output2_1_142 ;
wire [15:0] N_Key_output3_1_143 ;
wire GlobalResetSel;
assign Key_output3 = N_4;
assign Key_output2 = N_31;
assign Key_output1 = N_30;
assign Key_output = N_29;
  assign N_7 = z;
  assign N_10 = key_input3;
  assign N_9 = key_input2;
  assign N_6 = key_input1;
  assign N_5 = key_input;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen56_1_62 = GlobalEnable1;
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay1_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_6), .outp(N_19) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(3) ) Delay10_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_9), .outp(N_30) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(3) ) Delay11_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_10), .outp(N_31) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay2_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_20), .outp(N_21) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(2) ) Delay3_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_5), .outp(N_22) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay4_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_1), .outp(N_23) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay5_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_11), .outp(N_24) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay6_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_25), .outp(N_26) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(3) ) Delay8_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_12), .outp(N_28) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(2) ) Delay9_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_19), .outp(N_29) );
  generate
  begin: Shifter_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_10) ;
    assign N_15 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter (
      .inp(tmpIn),
      .shf(N_13[3:0]),
      .outp(medo)
   );
  end // Shifter_block;
  endgenerate
  generate
  begin: Shifter1_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_10) ;
    assign N_14 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter1 (
      .inp(tmpIn),
      .shf(N_2[3:0]),
      .outp(medo)
   );
  end // Shifter1_block;
  endgenerate
  generate
  begin: Shifter2_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_23) ;
    assign N_17 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter2 (
      .inp(tmpIn),
      .shf(N_3[3:0]),
      .outp(medo)
   );
  end // Shifter2_block;
  endgenerate
  generate
  begin: Shifter3_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_23) ;
    assign N_18 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter3 (
      .inp(tmpIn),
      .shf(N_16[3:0]),
      .outp(medo)
   );
  end // Shifter3_block;
  endgenerate
  generate
  begin: Binary_Logic7_block
    assign N_25 = (N_17 | N_18);
  end // Binary_Logic7_block;
  endgenerate
  generate
  begin: Binary_Logic6_block
    assign N_20 = (N_14 | N_15);
  end // Binary_Logic6_block;
  endgenerate
  generate
  begin: Binary_Logic5_block
    assign N_12 = (N_7 ^ N_8);
  end // Binary_Logic5_block;
  endgenerate
  generate
  begin: Binary_Logic4_block
    assign N_27 = (N_24 ^ N_26);
  end // Binary_Logic4_block;
  endgenerate
  generate
  begin: Binary_Logic3_block
    assign N_11 = (N_22 ^ N_23);
  end // Binary_Logic3_block;
  endgenerate
  generate
  begin: Binary_Logic2_block
    assign N_4 = (N_27 ^ N_28);
  end // Binary_Logic2_block;
  endgenerate
  generate
  begin: Binary_Logic1_block
    assign N_1 = (N_19 ^ N_21);
  end // Binary_Logic1_block;
  endgenerate
assign N_8 = 16'b1111111111111100;
assign N_16 = 4'b1111;
assign N_13 = 4'b1101;
assign N_3 = 4'b0001;
assign N_2 = 4'b0011;
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

module Sequence_ROM (clk,rst,en,inp,outp);
input clk;
input  rst, en;
input [6:0] inp;
output [0:0] outp;
wire [0:0] Sequence_ROM_CT [0:127];
wire rstSig;
assign rstSig = rst;
wire [0:0] outBuf;
reg  [0:0] romReg/*synthesis translate_off*/= 0/*synthesis translate_on*/;
  assign outBuf = romReg;
assign  outp=outBuf;
  generate
  begin: gen_Sequence_ROM
    assign Sequence_ROM_CT[0]=1'b0;
    assign Sequence_ROM_CT[1]=1'b0;
    assign Sequence_ROM_CT[2]=1'b0;
    assign Sequence_ROM_CT[3]=1'b0;
    assign Sequence_ROM_CT[4]=1'b1;
    assign Sequence_ROM_CT[5]=1'b1;
    assign Sequence_ROM_CT[6]=1'b1;
    assign Sequence_ROM_CT[7]=1'b1;
    assign Sequence_ROM_CT[8]=1'b1;
    assign Sequence_ROM_CT[9]=1'b1;
    assign Sequence_ROM_CT[10]=1'b1;
    assign Sequence_ROM_CT[11]=1'b1;
    assign Sequence_ROM_CT[12]=1'b1;
    assign Sequence_ROM_CT[13]=1'b1;
    assign Sequence_ROM_CT[14]=1'b1;
    assign Sequence_ROM_CT[15]=1'b1;
    assign Sequence_ROM_CT[16]=1'b1;
    assign Sequence_ROM_CT[17]=1'b1;
    assign Sequence_ROM_CT[18]=1'b1;
    assign Sequence_ROM_CT[19]=1'b1;
    assign Sequence_ROM_CT[20]=1'b1;
    assign Sequence_ROM_CT[21]=1'b1;
    assign Sequence_ROM_CT[22]=1'b1;
    assign Sequence_ROM_CT[23]=1'b1;
    assign Sequence_ROM_CT[24]=1'b1;
    assign Sequence_ROM_CT[25]=1'b1;
    assign Sequence_ROM_CT[26]=1'b1;
    assign Sequence_ROM_CT[27]=1'b1;
    assign Sequence_ROM_CT[28]=1'b1;
    assign Sequence_ROM_CT[29]=1'b1;
    assign Sequence_ROM_CT[30]=1'b1;
    assign Sequence_ROM_CT[31]=1'b1;
    assign Sequence_ROM_CT[32]=1'b1;
    assign Sequence_ROM_CT[33]=1'b1;
    assign Sequence_ROM_CT[34]=1'b1;
    assign Sequence_ROM_CT[35]=1'b1;
    assign Sequence_ROM_CT[36]=1'b1;
    assign Sequence_ROM_CT[37]=1'b1;
    assign Sequence_ROM_CT[38]=1'b1;
    assign Sequence_ROM_CT[39]=1'b1;
    assign Sequence_ROM_CT[40]=1'b1;
    assign Sequence_ROM_CT[41]=1'b1;
    assign Sequence_ROM_CT[42]=1'b1;
    assign Sequence_ROM_CT[43]=1'b1;
    assign Sequence_ROM_CT[44]=1'b1;
    assign Sequence_ROM_CT[45]=1'b1;
    assign Sequence_ROM_CT[46]=1'b1;
    assign Sequence_ROM_CT[47]=1'b1;
    assign Sequence_ROM_CT[48]=1'b1;
    assign Sequence_ROM_CT[49]=1'b1;
    assign Sequence_ROM_CT[50]=1'b1;
    assign Sequence_ROM_CT[51]=1'b1;
    assign Sequence_ROM_CT[52]=1'b1;
    assign Sequence_ROM_CT[53]=1'b1;
    assign Sequence_ROM_CT[54]=1'b1;
    assign Sequence_ROM_CT[55]=1'b1;
    assign Sequence_ROM_CT[56]=1'b1;
    assign Sequence_ROM_CT[57]=1'b1;
    assign Sequence_ROM_CT[58]=1'b1;
    assign Sequence_ROM_CT[59]=1'b1;
    assign Sequence_ROM_CT[60]=1'b1;
    assign Sequence_ROM_CT[61]=1'b1;
    assign Sequence_ROM_CT[62]=1'b1;
    assign Sequence_ROM_CT[63]=1'b1;
    assign Sequence_ROM_CT[64]=1'b1;
    assign Sequence_ROM_CT[65]=1'b1;
    assign Sequence_ROM_CT[66]=1'b1;
    assign Sequence_ROM_CT[67]=1'b1;
    assign Sequence_ROM_CT[68]=1'b1;
    assign Sequence_ROM_CT[69]=1'b1;
    assign Sequence_ROM_CT[70]=1'b1;
    assign Sequence_ROM_CT[71]=1'b1;
    assign Sequence_ROM_CT[72]=1'b1;
    assign Sequence_ROM_CT[73]=1'b1;
    assign Sequence_ROM_CT[74]=1'b1;
    assign Sequence_ROM_CT[75]=1'b1;
    assign Sequence_ROM_CT[76]=1'b1;
    assign Sequence_ROM_CT[77]=1'b1;
    assign Sequence_ROM_CT[78]=1'b1;
    assign Sequence_ROM_CT[79]=1'b1;
    assign Sequence_ROM_CT[80]=1'b1;
    assign Sequence_ROM_CT[81]=1'b1;
    assign Sequence_ROM_CT[82]=1'b1;
    assign Sequence_ROM_CT[83]=1'b1;
    assign Sequence_ROM_CT[84]=1'b1;
    assign Sequence_ROM_CT[85]=1'b1;
    assign Sequence_ROM_CT[86]=1'b1;
    assign Sequence_ROM_CT[87]=1'b1;
    assign Sequence_ROM_CT[88]=1'b1;
    assign Sequence_ROM_CT[89]=1'b1;
    assign Sequence_ROM_CT[90]=1'b1;
    assign Sequence_ROM_CT[91]=1'b1;
    assign Sequence_ROM_CT[92]=1'b1;
    assign Sequence_ROM_CT[93]=1'b1;
    assign Sequence_ROM_CT[94]=1'b1;
    assign Sequence_ROM_CT[95]=1'b1;
    assign Sequence_ROM_CT[96]=1'b1;
    assign Sequence_ROM_CT[97]=1'b1;
    assign Sequence_ROM_CT[98]=1'b1;
    assign Sequence_ROM_CT[99]=1'b1;
    assign Sequence_ROM_CT[100]=1'b1;
    assign Sequence_ROM_CT[101]=1'b1;
    assign Sequence_ROM_CT[102]=1'b1;
    assign Sequence_ROM_CT[103]=1'b1;
    assign Sequence_ROM_CT[104]=1'b1;
    assign Sequence_ROM_CT[105]=1'b1;
    assign Sequence_ROM_CT[106]=1'b1;
    assign Sequence_ROM_CT[107]=1'b1;
    assign Sequence_ROM_CT[108]=1'b1;
    assign Sequence_ROM_CT[109]=1'b1;
    assign Sequence_ROM_CT[110]=1'b1;
    assign Sequence_ROM_CT[111]=1'b1;
    assign Sequence_ROM_CT[112]=1'b1;
    assign Sequence_ROM_CT[113]=1'b1;
    assign Sequence_ROM_CT[114]=1'b1;
    assign Sequence_ROM_CT[115]=1'b1;
    assign Sequence_ROM_CT[116]=1'b1;
    assign Sequence_ROM_CT[117]=1'b1;
    assign Sequence_ROM_CT[118]=1'b1;
    assign Sequence_ROM_CT[119]=1'b1;
    assign Sequence_ROM_CT[120]=1'b1;
    assign Sequence_ROM_CT[121]=1'b1;
    assign Sequence_ROM_CT[122]=1'b1;
    assign Sequence_ROM_CT[123]=1'b1;
    assign Sequence_ROM_CT[124]=1'b1;
    assign Sequence_ROM_CT[125]=1'b1;
    assign Sequence_ROM_CT[126]=1'b1;
    assign Sequence_ROM_CT[127]=1'b1;
  end //gen_Sequence_ROM
  endgenerate
  always @(posedge clk)
  begin: Sequence_ROM_proc
    integer i;
    if(  rstSig==1) 
     begin
       romReg <= 1'b0;
     end
      else if(en) begin
        romReg <= Sequence_ROM_CT[inp];
  end // if en
  end // Sequence_ROM_proc
endmodule

//----------------------------------------------------

module Sequence (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output seq // ufix1
);
wire [0:0] N_2 ;
wire [6:0] N_1 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen49_1_55 ;
wire [0:0] N_GlobalEnable1_0_114 ;
wire [0:0] N_seq_1_115 ;
wire GlobalResetSel;
assign seq = N_2;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen49_1_55 = GlobalEnable1;
  generate
  begin: ROM_block
    wire [6:0] inbuf;
    wire syn_en;
    assign syn_en = N_GlobalEnable1_SubSystem_Convert_AutoGen49_1_55[0];
    assign inbuf=N_1[6:0];
    Sequence_ROM myROM (
     .clk(clk),
      .rst(GlobalResetSel),
      .en(syn_en),
     .inp(inbuf),
     .outp(N_2)
     );
  end // ROM_Block
  endgenerate
generate
begin:  Counter_block
wire [6:0] ldIn;
wire rst, en, enloc;
    assign enloc = 1;
    assign en = (enloc && N_GlobalEnable1_SubSystem_Convert_AutoGen49_1_55[0]);
    assign rst = 0;
assign ldIn = 7'b0;
    synCounter #(
        .en_exists('b1),
        .rst_exists('b0),
        .ld_exists('b0),
        .rdy_exists('b0),
        .ctype(2),
        .ival(0),
        .tval(127),
        .bitwidth(7),
        .isSigned('b0)
      ) myCounter (
        .clk(clk),
        .en(en),
        .grst(GlobalResetSel),
        .rst(rst),
        .up(1'b1),
        .ld(1'b0),
        .din(ldIn),
        .rdy(),
        .cnt(N_1)
      );
    end
  endgenerate
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

module Simon_encryption (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output [15:0] Key_output3, // ufix16_En0
  output [15:0] Key_output2, // ufix16_En0
  output [15:0] Key_output1, // ufix16_En0
  output [15:0] Key_output, // ufix16_En0
  output [15:0] X_output1, // ufix16_En0
  output [15:0] X_output, // ufix16_En0
  input [15:0] key_input3, // ufix16_En0
  input sel6, // ufix1
  input [15:0] key_input2, // ufix16_En0
  input sel5, // ufix1
  input [15:0] key_input1, // ufix16_En0
  input sel4, // ufix1
  input [15:0] key_input, // ufix16_En0
  input sel3, // ufix1
  input [15:0] x_input, // ufix16_En0
  input sel2, // ufix1
  input [15:0] x_input1, // ufix16_En0
  input sel1 // ufix1
);
wire [15:0] N_3 ;
wire [15:0] N_4 ;
wire [15:0] N_19 ;
wire [15:0] N_14 ;
wire [15:0] N_15 ;
wire [15:0] N_16 ;
wire [0:0] N_1 ;
wire [15:0] N_2 ;
wire [15:0] N_32 ;
wire [0:0] N_5 ;
wire [15:0] N_6 ;
wire [15:0] N_26 ;
wire [0:0] N_7 ;
wire [15:0] N_18 ;
wire [15:0] N_30 ;
wire [0:0] N_8 ;
wire [15:0] N_9 ;
wire [15:0] N_29 ;
wire [0:0] N_10 ;
wire [15:0] N_11 ;
wire [15:0] N_28 ;
wire [0:0] N_12 ;
wire [15:0] N_13 ;
wire [15:0] N_27 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen55_1_61 ;
wire [15:0] N_20 ;
wire [15:0] N_21 ;
wire [15:0] N_22 ;
wire [15:0] N_23 ;
wire [15:0] N_24 ;
wire [15:0] N_25 ;
wire [15:0] N_31 ;
wire [0:0] N_GlobalEnable1_0_144 ;
wire [0:0] N_sel1_0_145 ;
wire [15:0] N_x_input1_0_146 ;
wire [0:0] N_sel2_0_147 ;
wire [15:0] N_x_input_0_148 ;
wire [0:0] N_sel3_0_149 ;
wire [15:0] N_key_input_0_150 ;
wire [0:0] N_sel4_0_151 ;
wire [15:0] N_key_input1_0_152 ;
wire [0:0] N_sel5_0_153 ;
wire [15:0] N_key_input2_0_154 ;
wire [0:0] N_sel6_0_155 ;
wire [15:0] N_key_input3_0_156 ;
wire [15:0] N_X_output_1_157 ;
wire [15:0] N_X_output1_1_158 ;
wire [15:0] N_Key_output_1_159 ;
wire [15:0] N_Key_output1_1_160 ;
wire [15:0] N_Key_output2_1_161 ;
wire [15:0] N_Key_output3_1_162 ;
wire GlobalResetSel;
assign Key_output3 = N_16;
assign Key_output2 = N_15;
assign Key_output1 = N_14;
assign Key_output = N_19;
assign X_output1 = N_4;
assign X_output = N_3;
  assign N_13 = key_input3;
  assign N_12 = sel6;
  assign N_11 = key_input2;
  assign N_10 = sel5;
  assign N_9 = key_input1;
  assign N_8 = sel4;
  assign N_18 = key_input;
  assign N_7 = sel3;
  assign N_6 = x_input;
  assign N_5 = sel2;
  assign N_2 = x_input1;
  assign N_1 = sel1;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen55_1_61 = GlobalEnable1;
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay1_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_3), .outp(N_26) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay2_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_4), .outp(N_32) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay3_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_19), .outp(N_30) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay4_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_14), .outp(N_29) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay5_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_15), .outp(N_28) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay6_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_16), .outp(N_27) );
  assign N_20 = (N_1 == 0) ? N_2 : N_32; // mux block
  assign N_21 = (N_5 == 0) ? N_6 : N_26; // mux block
  assign N_22 = (N_7 == 0) ? N_18 : N_30; // mux block
  assign N_23 = (N_8 == 0) ? N_9 : N_29; // mux block
  assign N_24 = (N_10 == 0) ? N_11 : N_28; // mux block
  assign N_25 = (N_12 == 0) ? N_13 : N_27; // mux block
    Simon_encryption_0Sequence  mySequence (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .seq(N_31)    );
    Simon_encryption_0Rounds_block  myRounds_block (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      ._x_input1(N_20),
      .x_input(N_21),
      .key_input(N_22),
      .X_output1(N_3) ,
      .X_output2(N_4)    );
    Simon_encryption_0Key_expansion_block  myKey_expansion_block (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .key_input(N_22),
      .key_input1(N_23),
      .key_input2(N_24),
      .key_input3(N_25),
      .z(N_31),
      .Key_output(N_19) ,
      .Key_output1(N_14) ,
      .Key_output2(N_15) ,
      .Key_output3(N_16)    );
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

//@
module simon_internal_pipelined_interleaved (
  input clk,
  input GlobalReset,
  output [15:0] Port_Out5, // ufix16_En0
  output [15:0] Port_Out4, // ufix16_En0
  output [15:0] Port_Out3, // ufix16_En0
  output [15:0] Port_Out2, // ufix16_En0
  output [15:0] Port_Out1, // ufix16_En0
  output [15:0] Port_Out, // ufix16_En0
  input [15:0] Port_In5, // ufix16_En0
  input [15:0] Port_In4, // ufix16_En0
  input [15:0] Port_In3, // ufix16_En0
  input [15:0] Port_In2, // ufix16_En0
  input [15:0] Port_In1, // ufix16_En0
  input [15:0] Port_In // ufix16_En0
//@
);
//@

wire [15:0] N_8 ;
wire [15:0] N_9 ;
wire [15:0] N_10 ;
wire [15:0] N_11 ;
wire [15:0] N_12 ;
wire [15:0] N_13 ;
wire [0:0] GlobalEnableSignal1 ;
wire [15:0] N_1 ;
wire [15:0] N_2 ;
wire [15:0] N_3 ;
wire [15:0] N_4 ;
wire [15:0] N_5 ;
wire [15:0] N_6 ;
wire [0:0] N_25 ;
wire [0:0] N_24 ;
wire [0:0] N_23 ;
wire [0:0] N_22 ;
wire [0:0] N_21 ;
wire [0:0] N_20 ;
wire GlobalResetSel;
  wire GlobalEnable1;
  assign GlobalEnable1 = 1;
    Sequence  mySequence (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .seq(N_20)    );
    Sequence  mySequence1 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .seq(N_21)    );
    Sequence  mySequence2 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .seq(N_22)    );
    Sequence  mySequence3 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .seq(N_23)    );
    Sequence  mySequence4 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .seq(N_24)    );
    Sequence  mySequence5 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .seq(N_25)    );
    Simon_encryption  mySimon_encryption (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .sel1(N_20),
      .x_input1(N_8),
      .sel2(N_21),
      .x_input(N_9),
      .sel3(N_22),
      .key_input(N_10),
      .sel4(N_23),
      .key_input1(N_11),
      .sel5(N_24),
      .key_input2(N_12),
      .sel6(N_25),
      .key_input3(N_13),
      .X_output(N_1) ,
      .X_output1(N_2) ,
      .Key_output(N_3) ,
      .Key_output1(N_4) ,
      .Key_output2(N_5) ,
      .Key_output3(N_6)    );
  assign GlobalEnableSignal1 = GlobalEnable1;
  generate
  begin: Port_Out5_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out5_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_6;
  assign Port_Out5 = med;
  end // Port_Out5_Block
  endgenerate
  generate
  begin: Port_Out4_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out4_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_5;
  assign Port_Out4 = med;
  end // Port_Out4_Block
  endgenerate
  generate
  begin: Port_Out3_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out3_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_4;
  assign Port_Out3 = med;
  end // Port_Out3_Block
  endgenerate
  generate
  begin: Port_Out2_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out2_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_3;
  assign Port_Out2 = med;
  end // Port_Out2_Block
  endgenerate
  generate
  begin: Port_Out1_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out1_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_2;
  assign Port_Out1 = med;
  end // Port_Out1_Block
  endgenerate
  generate
  begin: Port_Out_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_1;
  assign Port_Out = med;
  end // Port_Out_Block
  endgenerate
  generate
  begin: Port_In5_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In5_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In5;
  end // inProc
  assign out_tmp = med;
  assign N_13 = out_tmp;
  end // Port_In5_Block
  endgenerate
  generate
  begin: Port_In4_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In4_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In4;
  end // inProc
  assign out_tmp = med;
  assign N_12 = out_tmp;
  end // Port_In4_Block
  endgenerate
  generate
  begin: Port_In3_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In3_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In3;
  end // inProc
  assign out_tmp = med;
  assign N_11 = out_tmp;
  end // Port_In3_Block
  endgenerate
  generate
  begin: Port_In2_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In2_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In2;
  end // inProc
  assign out_tmp = med;
  assign N_10 = out_tmp;
  end // Port_In2_Block
  endgenerate
  generate
  begin: Port_In1_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In1_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In1;
  end // inProc
  assign out_tmp = med;
  assign N_9 = out_tmp;
  end // Port_In1_Block
  endgenerate
  generate
  begin: Port_In_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In;
  end // inProc
  assign out_tmp = med;
  assign N_8 = out_tmp;
  end // Port_In_Block
  endgenerate
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

