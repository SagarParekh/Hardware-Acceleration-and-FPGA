// ********************************************************************
//
// Copyright (C) 1994-2016 Synopsys, Inc. All rights reserved. This Synopsys software and all associated documentation are proprietary to Synopsys, Inc. and may only be used pursuant to the terms and conditions of a written license agreement with Synopsys, Inc. All other use, reproduction, modification, or distribution of the Synopsys software or the associated documentation is strictly prohibited.

// This code was generated by Synopsys's Synphony Model Compiler product and
// is intended for use solely by licensed users of this product.

// VERILOG created by Synphony Model Compiler L-2016.03, Build 2009R, Feb 25 2016
// Date written:             Sun Apr 15 16:23:14 2018

// ********************************************************************

// Generated from /afs/asu.edu/users/v/c/h/vchand32/Downloads/simon_baseline_initial.slx Version 1.114 Last modified date Sun Apr 15 16:18:54 2018
module Simon_encryption_block_0Sequence_ROM (clk,rst,en,inp,outp);
input clk;
input  rst, en;
input [4:0] inp;
output [15:0] outp;
wire [15:0] Simon_encryption_block_0Sequence_ROM_CT [0:31];
wire rstSig;
assign rstSig = rst;
wire [15:0] outBuf;
reg  [15:0] romReg/*synthesis translate_off*/= 0/*synthesis translate_on*/;
wire [4:0] inpTr;
wire valid, validReg;
  assign outBuf = validReg == 1 ? romReg : 16'b0;
  assign valid = (inp >= 31) ? 0 : 1;
  assign inpTr = inp[4:0];
    synDelayWithEnable #( .bitwidth(1), .delaylength(1) ) validDly_block ( .clk(clk), .en(en), .grst(rstSig), .rst(1'b0), .inp(valid), .outp(validReg) );
assign  outp=outBuf;
  generate
  begin: gen_Simon_encryption_block_0Sequence_ROM
    assign Simon_encryption_block_0Sequence_ROM_CT[0]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[1]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[2]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[3]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[4]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[5]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[6]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[7]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[8]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[9]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[10]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[11]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[12]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[13]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[14]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[15]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[16]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[17]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[18]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[19]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[20]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[21]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[22]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[23]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[24]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[25]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[26]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[27]=16'b0000000000000000;
    assign Simon_encryption_block_0Sequence_ROM_CT[28]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[29]=16'b0000000000000001;
    assign Simon_encryption_block_0Sequence_ROM_CT[30]=16'b0000000000000000;
    genvar i;
    for (i=31; i<32; i=i+1)
    begin: axes_Simon_encryption_block_0Sequence_ROM
      assign Simon_encryption_block_0Sequence_ROM_CT[i] = 16'b0;
    end
  end //gen_Simon_encryption_block_0Sequence_ROM
  endgenerate
  always @(posedge clk)
  begin: Simon_encryption_block_0Sequence_ROM_proc
    integer i;
    if(  rstSig==1) 
     begin
       romReg <= 16'b0;
     end
      else if(en) begin
        romReg <= Simon_encryption_block_0Sequence_ROM_CT[inpTr];
  end // if en
  end // Simon_encryption_block_0Sequence_ROM_proc
endmodule

//----------------------------------------------------

module Simon_encryption_block_0Sequence (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output [15:0] seq // ufix16_En0
);
wire [15:0] N_2 ;
wire [4:0] N_1 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen53_1_59 ;
wire [0:0] N_GlobalEnable1_0_109 ;
wire [15:0] N_seq_1_110 ;
wire GlobalResetSel;
assign seq = N_2;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen53_1_59 = GlobalEnable1;
  generate
  begin: ROM_block
    wire [4:0] inbuf;
    wire syn_en;
    assign syn_en = N_GlobalEnable1_SubSystem_Convert_AutoGen53_1_59[0];
    assign inbuf=N_1[4:0];
    Simon_encryption_block_0Sequence_ROM myROM (
     .clk(clk),
      .rst(GlobalResetSel),
      .en(syn_en),
     .inp(inbuf),
     .outp(N_2)
     );
  end // ROM_Block
  endgenerate
generate
begin:  Counter_block
wire [4:0] ldIn;
wire rst, en, enloc;
    assign enloc = 1;
    assign en = (enloc && N_GlobalEnable1_SubSystem_Convert_AutoGen53_1_59[0]);
    assign rst = 0;
assign ldIn = 5'b0;
    synCounter #(
        .en_exists('b1),
        .rst_exists('b0),
        .ld_exists('b0),
        .rdy_exists('b0),
        .ctype(2),
        .ival(0),
        .tval(30),
        .bitwidth(5),
        .isSigned('b0)
      ) myCounter (
        .clk(clk),
        .en(en),
        .grst(GlobalResetSel),
        .rst(rst),
        .up(1'b1),
        .ld(1'b0),
        .din(ldIn),
        .rdy(),
        .cnt(N_1)
      );
    end
  endgenerate
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

module Simon_encryption_block_0Rounds_block (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output [15:0] X_output, // ufix16_En0
  output [15:0] X_output1, // ufix16_En0
  input [15:0] key_input, // ufix16_En0
  input [15:0] x_input, // ufix16_En0
  input [15:0] _x_input1 // ufix16_En0
);
wire [15:0] N_6 ;
wire [3:0] N_2 ;
wire [3:0] N_8 ;
wire [3:0] N_3 ;
wire [3:0] N_12 ;
wire [3:0] N_16 ;
wire [3:0] N_18 ;
wire [15:0] N_4 ;
wire [15:0] N_17 ;
wire [15:0] N_19 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen52_1_58 ;
wire [15:0] N_13 ;
wire [15:0] N_14 ;
wire [15:0] N_21 ;
wire [15:0] N_20 ;
wire [15:0] N_9 ;
wire [15:0] N_10 ;
wire [15:0] N_5 ;
wire [15:0] N_22 ;
wire [15:0] N_1 ;
wire [15:0] N_7 ;
wire [15:0] N_11 ;
wire [15:0] N_15 ;
wire [0:0] N_GlobalEnable1_0_111 ;
wire [15:0] N_0x_input1_0_112 ;
wire [15:0] N_x_input_0_113 ;
wire [15:0] N_key_input_0_114 ;
wire [15:0] N_X_output1_1_115 ;
wire [15:0] N_X_output_1_116 ;
wire GlobalResetSel;
assign X_output = N_4;
assign X_output1 = N_6;
  assign N_7 = key_input;
  assign N_5 = x_input;
  assign N_6 = _x_input1;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen52_1_58 = GlobalEnable1;
  generate
  begin: Shifter_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_9 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter (
      .inp(tmpIn),
      .shf(N_2[3:0]),
      .outp(medo)
   );
  end // Shifter_block;
  endgenerate
  generate
  begin: Shifter1_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_10 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter1 (
      .inp(tmpIn),
      .shf(N_8[3:0]),
      .outp(medo)
   );
  end // Shifter1_block;
  endgenerate
  generate
  begin: Shifter2_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_13 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter2 (
      .inp(tmpIn),
      .shf(N_3[3:0]),
      .outp(medo)
   );
  end // Shifter2_block;
  endgenerate
  generate
  begin: Shifter3_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_14 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter3 (
      .inp(tmpIn),
      .shf(N_12[3:0]),
      .outp(medo)
   );
  end // Shifter3_block;
  endgenerate
  generate
  begin: Shifter4_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_17 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter4 (
      .inp(tmpIn),
      .shf(N_16[3:0]),
      .outp(medo)
   );
  end // Shifter4_block;
  endgenerate
  generate
  begin: Shifter5_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_6) ;
    assign N_19 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter5 (
      .inp(tmpIn),
      .shf(N_18[3:0]),
      .outp(medo)
   );
  end // Shifter5_block;
  endgenerate
  generate
  begin: Binary_Logic6_block
    assign N_20 = (N_17 | N_19);
  end // Binary_Logic6_block;
  endgenerate
  generate
  begin: Binary_Logic5_block
    assign N_15 = (N_13 | N_14);
  end // Binary_Logic5_block;
  endgenerate
  generate
  begin: Binary_Logic4_block
    assign N_1 = (N_21 ^ N_20);
  end // Binary_Logic4_block;
  endgenerate
  generate
  begin: Binary_Logic3_block
    assign N_11 = (N_9 | N_10);
  end // Binary_Logic3_block;
  endgenerate
  generate
  begin: Binary_Logic2_block
    assign N_21 = (N_5 ^ N_22);
  end // Binary_Logic2_block;
  endgenerate
  generate
  begin: Binary_Logic1_block
    assign N_4 = (N_1 ^ N_7);
  end // Binary_Logic1_block;
  endgenerate
  generate
  begin: Binary_Logic_block
    assign N_22 = (N_11 & N_15);
  end // Binary_Logic_block;
  endgenerate
assign N_18 = 4'b1110;
assign N_12 = 4'b1000;
assign N_8 = 4'b1111;
assign N_16 = 4'b0010;
assign N_3 = 4'b1000;
assign N_2 = 4'b0001;
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

module Simon_encryption_block_0Keyexpansion_block (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output [15:0] Key_output3, // ufix16_En0
  output [15:0] Key_output2, // ufix16_En0
  output [15:0] Key_output1, // ufix16_En0
  output [15:0] Key_output, // ufix16_En0
  input [15:0] z, // ufix16_En0
  input [15:0] key_input3, // ufix16_En0
  input [15:0] key_input2, // ufix16_En0
  input [15:0] key_input1, // ufix16_En0
  input [15:0] key_input // ufix16_En0
);
wire [15:0] N_11 ;
wire [3:0] N_14 ;
wire [3:0] N_2 ;
wire [15:0] N_1 ;
wire [3:0] N_3 ;
wire [3:0] N_18 ;
wire [15:0] N_4 ;
wire [15:0] N_10 ;
wire [15:0] N_7 ;
wire [15:0] N_19 ;
wire [15:0] N_20 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen51_1_57 ;
wire [15:0] N_15 ;
wire [15:0] N_16 ;
wire [15:0] N_8 ;
wire [15:0] N_9 ;
wire [15:0] N_12 ;
wire [15:0] N_21 ;
wire [15:0] N_6 ;
wire [15:0] N_5 ;
wire [15:0] N_13 ;
wire [15:0] N_17 ;
wire [0:0] N_GlobalEnable1_0_117 ;
wire [15:0] N_key_input_0_118 ;
wire [15:0] N_key_input1_0_119 ;
wire [15:0] N_key_input2_0_120 ;
wire [15:0] N_key_input3_0_121 ;
wire [15:0] N_z_0_122 ;
wire [15:0] N_Key_output_1_123 ;
wire [15:0] N_Key_output1_1_124 ;
wire [15:0] N_Key_output2_1_125 ;
wire [15:0] N_Key_output3_1_126 ;
wire GlobalResetSel;
assign Key_output3 = N_4;
assign Key_output2 = N_11;
assign Key_output1 = N_10;
assign Key_output = N_7;
  assign N_8 = z;
  assign N_11 = key_input3;
  assign N_10 = key_input2;
  assign N_7 = key_input1;
  assign N_6 = key_input;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen51_1_57 = GlobalEnable1;
  generate
  begin: Shifter_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_11) ;
    assign N_16 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter (
      .inp(tmpIn),
      .shf(N_14[3:0]),
      .outp(medo)
   );
  end // Shifter_block;
  endgenerate
  generate
  begin: Shifter1_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_11) ;
    assign N_15 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter1 (
      .inp(tmpIn),
      .shf(N_2[3:0]),
      .outp(medo)
   );
  end // Shifter1_block;
  endgenerate
  generate
  begin: Shifter2_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_1) ;
    assign N_19 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("rightshift")
    ) Shifter2 (
      .inp(tmpIn),
      .shf(N_3[3:0]),
      .outp(medo)
   );
  end // Shifter2_block;
  endgenerate
  generate
  begin: Shifter3_block
    wire [15:0] medo;
    wire [15:0] tmpIn;
    assign tmpIn = (N_1) ;
    assign N_20 = medo[15:0];
    synShifter #(
      .inpBitW(16),
      .outBitW(16),
      .shfBitW(4),
      .datatype("unsign"),
      .opr("leftshift")
    ) Shifter3 (
      .inp(tmpIn),
      .shf(N_18[3:0]),
      .outp(medo)
   );
  end // Shifter3_block;
  endgenerate
  generate
  begin: Binary_Logic7_block
    assign N_21 = (N_19 | N_20);
  end // Binary_Logic7_block;
  endgenerate
  generate
  begin: Binary_Logic6_block
    assign N_17 = (N_15 | N_16);
  end // Binary_Logic6_block;
  endgenerate
  generate
  begin: Binary_Logic5_block
    assign N_13 = (N_8 ^ N_9);
  end // Binary_Logic5_block;
  endgenerate
  generate
  begin: Binary_Logic4_block
    assign N_5 = (N_12 ^ N_21);
  end // Binary_Logic4_block;
  endgenerate
  generate
  begin: Binary_Logic3_block
    assign N_12 = (N_6 ^ N_1);
  end // Binary_Logic3_block;
  endgenerate
  generate
  begin: Binary_Logic2_block
    assign N_4 = (N_5 ^ N_13);
  end // Binary_Logic2_block;
  endgenerate
  generate
  begin: Binary_Logic1_block
    assign N_1 = (N_7 ^ N_17);
  end // Binary_Logic1_block;
  endgenerate
assign N_9 = 16'b1111111111111100;
assign N_18 = 4'b1111;
assign N_14 = 4'b1101;
assign N_3 = 4'b0001;
assign N_2 = 4'b0011;
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

module synPulse_Generator_Shift_Register (clk,grst,rst,en,d,q1);
parameter bitwidth=1;
parameter depth=2;
input clk;
input [bitwidth-1:0] d;
input grst;
input rst;
input en;
output [bitwidth-1:0] q1;
wire [bitwidth-1:0] qTemp1;
  assign q1 = qTemp1;
    synDelayWithEnable #( .bitwidth(bitwidth), .delaylength(2) ) Delay0_block ( .clk(clk), .en(en), .grst(grst), .rst(rst), .inp(d), .outp(qTemp1) );
endmodule

//----------------------------------------------------

module Pulse_Generator (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output pulse // ufix1
);
wire [0:0] N_1 ;
wire [0:0] N_2 ;
wire [0:0] N_pulse_1_108 ;
wire GlobalResetSel;
assign pulse = N_2;
  generate
  begin: Shift_Register_block
    wire [0:0] outBuf0;
    wire rst, enab;
    assign rst = 0;
    assign enab = GlobalEnable1;
  synPulse_Generator_Shift_Register myShift_Register(
      .clk(clk),
      .d(N_1),
        .grst(GlobalResetSel),
        .rst(rst),
        .en(enab),
      .q1(outBuf0)
    );
    assign N_2 = outBuf0;
  end //Shift_Register_block;
  endgenerate
assign N_1 = 1'b1;
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

module Simon_encryption_block (
  input clk,
  input GlobalEnable1,
  input GlobalReset,
  output [15:0] Key_output3, // ufix16_En0
  output [15:0] Key_output2, // ufix16_En0
  output [15:0] Key_output1, // ufix16_En0
  output [15:0] Key_output, // ufix16_En0
  output [15:0] X_output1, // ufix16_En0
  output [15:0] X_output, // ufix16_En0
  input [15:0] key_input3, // ufix16_En0
  input sel6, // ufix1
  input [15:0] key_input2, // ufix16_En0
  input sel5, // ufix1
  input [15:0] key_input1, // ufix16_En0
  input sel4, // ufix1
  input [15:0] key_input, // ufix16_En0
  input sel3, // ufix1
  input [15:0] x_input, // ufix16_En0
  input sel2, // ufix1
  input [15:0] x_input1, // ufix16_En0
  input sel1 // ufix1
);
wire [15:0] N_3 ;
wire [15:0] N_4 ;
wire [15:0] N_19 ;
wire [15:0] N_14 ;
wire [15:0] N_15 ;
wire [15:0] N_16 ;
wire [0:0] N_1 ;
wire [15:0] N_2 ;
wire [15:0] N_32 ;
wire [0:0] N_5 ;
wire [15:0] N_6 ;
wire [15:0] N_26 ;
wire [0:0] N_7 ;
wire [15:0] N_18 ;
wire [15:0] N_30 ;
wire [0:0] N_8 ;
wire [15:0] N_9 ;
wire [15:0] N_29 ;
wire [0:0] N_10 ;
wire [15:0] N_11 ;
wire [15:0] N_28 ;
wire [0:0] N_12 ;
wire [15:0] N_13 ;
wire [15:0] N_27 ;
wire [0:0] N_GlobalEnable1_SubSystem_Convert_AutoGen50_1_56 ;
wire [15:0] N_20 ;
wire [15:0] N_21 ;
wire [15:0] N_22 ;
wire [15:0] N_23 ;
wire [15:0] N_24 ;
wire [15:0] N_25 ;
wire [15:0] N_31 ;
wire [0:0] N_GlobalEnable1_0_127 ;
wire [0:0] N_sel1_0_128 ;
wire [15:0] N_x_input1_0_129 ;
wire [0:0] N_sel2_0_130 ;
wire [15:0] N_x_input_0_131 ;
wire [0:0] N_sel3_0_132 ;
wire [15:0] N_key_input_0_133 ;
wire [0:0] N_sel4_0_134 ;
wire [15:0] N_key_input1_0_135 ;
wire [0:0] N_sel5_0_136 ;
wire [15:0] N_key_input2_0_137 ;
wire [0:0] N_sel6_0_138 ;
wire [15:0] N_key_input3_0_139 ;
wire [15:0] N_X_output_1_140 ;
wire [15:0] N_X_output1_1_141 ;
wire [15:0] N_Key_output_1_142 ;
wire [15:0] N_Key_output1_1_143 ;
wire [15:0] N_Key_output2_1_144 ;
wire [15:0] N_Key_output3_1_145 ;
wire GlobalResetSel;
assign Key_output3 = N_16;
assign Key_output2 = N_15;
assign Key_output1 = N_14;
assign Key_output = N_19;
assign X_output1 = N_4;
assign X_output = N_3;
  assign N_13 = key_input3;
  assign N_12 = sel6;
  assign N_11 = key_input2;
  assign N_10 = sel5;
  assign N_9 = key_input1;
  assign N_8 = sel4;
  assign N_18 = key_input;
  assign N_7 = sel3;
  assign N_6 = x_input;
  assign N_5 = sel2;
  assign N_2 = x_input1;
  assign N_1 = sel1;
  assign N_GlobalEnable1_SubSystem_Convert_AutoGen50_1_56 = GlobalEnable1;
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay1_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_3), .outp(N_26) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay2_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_4), .outp(N_32) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay3_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_19), .outp(N_30) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay4_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_14), .outp(N_29) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay5_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_15), .outp(N_28) );
    synDelayWithEnable #( .bitwidth(16), .delaylength(1) ) Delay6_block ( .clk(clk), .en(GlobalEnable1), .grst(GlobalResetSel), .rst(1'b0), .inp(N_16), .outp(N_27) );
  assign N_20 = (N_1 == 0) ? N_2 : N_32; // mux block
  assign N_21 = (N_5 == 0) ? N_6 : N_26; // mux block
  assign N_22 = (N_7 == 0) ? N_18 : N_30; // mux block
  assign N_23 = (N_8 == 0) ? N_9 : N_29; // mux block
  assign N_24 = (N_10 == 0) ? N_11 : N_28; // mux block
  assign N_25 = (N_12 == 0) ? N_13 : N_27; // mux block
    Simon_encryption_block_0Sequence  mySequence (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .seq(N_31)    );
    Simon_encryption_block_0Rounds_block  myRounds_block (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      ._x_input1(N_20),
      .x_input(N_21),
      .key_input(N_22),
      .X_output1(N_3) ,
      .X_output(N_4)    );
    Simon_encryption_block_0Keyexpansion_block  myKeyexpansion_block (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .key_input(N_22),
      .key_input1(N_23),
      .key_input2(N_24),
      .key_input3(N_25),
      .z(N_31),
      .Key_output(N_19) ,
      .Key_output1(N_14) ,
      .Key_output2(N_15) ,
      .Key_output3(N_16)    );
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

//@
module simon_baseline_initial (
  input clk,
  input GlobalReset,
  output [15:0] Port_Out5, // ufix16_En0
  output [15:0] Port_Out4, // ufix16_En0
  output [15:0] Port_Out3, // ufix16_En0
  output [15:0] Port_Out2, // ufix16_En0
  output [15:0] Port_Out1, // ufix16_En0
  output [15:0] Port_Out, // ufix16_En0
  input [15:0] Port_In5, // ufix16_En0
  input [15:0] Port_In4, // ufix16_En0
  input [15:0] Port_In3, // ufix16_En0
  input [15:0] Port_In2, // ufix16_En0
  input [15:0] Port_In1, // ufix16_En0
  input [15:0] Port_In // ufix16_En0
//@
);
//@

wire [15:0] N_8 ;
wire [15:0] N_9 ;
wire [15:0] N_10 ;
wire [15:0] N_11 ;
wire [15:0] N_12 ;
wire [15:0] N_13 ;
wire [0:0] GlobalEnableSignal1 ;
wire [15:0] N_1 ;
wire [15:0] N_2 ;
wire [15:0] N_3 ;
wire [15:0] N_4 ;
wire [15:0] N_5 ;
wire [15:0] N_6 ;
wire [0:0] N_20 ;
wire [0:0] N_21 ;
wire [0:0] N_22 ;
wire [0:0] N_23 ;
wire [0:0] N_24 ;
wire [0:0] N_25 ;
wire GlobalResetSel;
  wire GlobalEnable1;
  assign GlobalEnable1 = 1;
    Pulse_Generator  myPulse_Generator5 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .pulse(N_25)    );
    Pulse_Generator  myPulse_Generator4 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .pulse(N_24)    );
    Pulse_Generator  myPulse_Generator3 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .pulse(N_23)    );
    Pulse_Generator  myPulse_Generator2 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .pulse(N_22)    );
    Pulse_Generator  myPulse_Generator1 (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .pulse(N_21)    );
    Pulse_Generator  myPulse_Generator (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .pulse(N_20)    );
    Simon_encryption_block  mySimon_encryption_block (
      .clk(clk),
      .GlobalEnable1(GlobalEnable1),
      .GlobalReset(GlobalResetSel),
      .sel1(N_20),
      .x_input1(N_8),
      .sel2(N_21),
      .x_input(N_9),
      .sel3(N_22),
      .key_input(N_10),
      .sel4(N_23),
      .key_input1(N_11),
      .sel5(N_24),
      .key_input2(N_12),
      .sel6(N_25),
      .key_input3(N_13),
      .X_output(N_1) ,
      .X_output1(N_2) ,
      .Key_output(N_3) ,
      .Key_output1(N_4) ,
      .Key_output2(N_5) ,
      .Key_output3(N_6)    );
  assign GlobalEnableSignal1 = GlobalEnable1;
  generate
  begin: Port_Out5_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out5_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_6;
  assign Port_Out5 = med;
  end // Port_Out5_Block
  endgenerate
  generate
  begin: Port_Out4_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out4_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_5;
  assign Port_Out4 = med;
  end // Port_Out4_Block
  endgenerate
  generate
  begin: Port_Out3_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out3_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_4;
  assign Port_Out3 = med;
  end // Port_Out3_Block
  endgenerate
  generate
  begin: Port_Out2_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out2_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_3;
  assign Port_Out2 = med;
  end // Port_Out2_Block
  endgenerate
  generate
  begin: Port_Out1_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out1_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_2;
  assign Port_Out1 = med;
  end // Port_Out1_Block
  endgenerate
  generate
  begin: Port_Out_block
    reg [15:0] med;
    wire [15:0] inp_tmp /* synthesis syn_keep = 1 */;
  always @(posedge clk)
  begin: Port_Out_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= inp_tmp;
  end // inProc
  assign inp_tmp = N_1;
  assign Port_Out = med;
  end // Port_Out_Block
  endgenerate
  generate
  begin: Port_In5_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In5_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In5;
  end // inProc
  assign out_tmp = med;
  assign N_13 = out_tmp;
  end // Port_In5_Block
  endgenerate
  generate
  begin: Port_In4_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In4_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In4;
  end // inProc
  assign out_tmp = med;
  assign N_12 = out_tmp;
  end // Port_In4_Block
  endgenerate
  generate
  begin: Port_In3_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In3_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In3;
  end // inProc
  assign out_tmp = med;
  assign N_11 = out_tmp;
  end // Port_In3_Block
  endgenerate
  generate
  begin: Port_In2_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In2_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In2;
  end // inProc
  assign out_tmp = med;
  assign N_10 = out_tmp;
  end // Port_In2_Block
  endgenerate
  generate
  begin: Port_In1_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In1_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In1;
  end // inProc
  assign out_tmp = med;
  assign N_9 = out_tmp;
  end // Port_In1_Block
  endgenerate
  generate
  begin: Port_In_block
    wire [15:0] out_tmp /* synthesis syn_keep = 1 */;
    reg [15:0] med;
  always @(posedge clk)
  begin: Port_In_proc
    integer i;
    if(GlobalResetSel==1) 
      med <= 0;
    else if( GlobalEnable1==1)
      med <= Port_In;
  end // inProc
  assign out_tmp = med;
  assign N_8 = out_tmp;
  end // Port_In_Block
  endgenerate
assign GlobalResetSel = GlobalReset;
endmodule

//-----------------------------------------

